#!KAMAILIO
#
# Kamailio - Custom WebRTC Signaling Server
# Purpose: Convert JSON WebSocket messages → SIP
# Architecture: Browser (Custom Protocol) → Kamailio → Asterisk → Genesys
#

####### Global Parameters #########

debug=3
log_stderror=yes
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

fork=yes
children=4

# TCP settings
disable_tcp=no
tcp_children=4
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

# Listen interfaces
listen=udp:192.168.210.54:5070
listen=tcp:192.168.210.54:5070
listen=tcp:192.168.210.54:8080

# Aliases
alias=192.168.210.54

# Server header
server_signature=no
user_agent_header="User-Agent: Kamailio Custom Signaling"

####### Modules Section ########

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"

# Authentication
loadmodule "auth.so"

# NAT traversal
loadmodule "usrloc.so"
loadmodule "nathelper.so"

# WebSocket
loadmodule "websocket.so"
loadmodule "xhttp.so"

# Path support
loadmodule "path.so"

# JSON and HTTP
loadmodule "jansson.so"
loadmodule "http_client.so"
loadmodule "htable.so"

# SDP manipulation
loadmodule "sdpops.so"

# JSON RPC for API
loadmodule "jsonrpcs.so"

# UAC (User Agent Client) for generating requests
loadmodule "uac.so"

# Dialog tracking (for live call monitoring)
loadmodule "dialog.so"

####### Module Parameters ########

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 0)

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# ----- path params -----
modparam("path", "use_received", 1)

# ----- jansson params -----
# JSON parsing for custom protocol

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 7)

# ----- http_client params -----
modparam("http_client", "httpcon", "genesys=>http://192.168.210.81:8080/api")
modparam("http_client", "connection_timeout", 2)

# ----- htable params -----
# Store WebSocket connection info by DN
modparam("htable", "htable", "wsconn=>size=8;autoexpire=3600")
# Store call info by call ID
modparam("htable", "htable", "calls=>size=16;autoexpire=7200")

# ----- uac params -----
modparam("uac", "reg_db_url", "")
modparam("uac", "restore_mode", "auto")

# ----- dialog params -----
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(dlg_timeout)")
modparam("dialog", "default_timeout", 21600)  # 6 hours
modparam("dialog", "dlg_extra_hdrs", "X-Kamailio-Dialog: yes\r\n")
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "profiles_with_value", "caller")

####### Routing Logic ########

request_route {
    # Per-request initial checks
    route(REQINIT);
    
    # WebSocket requests
    if (is_method("GET") && $hdr(Upgrade) =~ "websocket") {
        xlog("L_INFO", "WebSocket connection request\n");
        route(WEBSOCKET);
        exit;
    }
    
    # HTTP API requests
    if (is_method("GET|POST") && $hdr(Content-Type) =~ "application/json") {
        xlog("L_INFO", "HTTP API request: $rm $ru\n");
        route(HTTPAPI);
        exit;
    }
    
    # Standard SIP routing
    route(SIPHANDLER);
}

####### Helper Routes ########

route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }
    
    # Sanity checks
    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }
}

####### WebSocket Handling ########

route[WEBSOCKET] {
    if (ws_handle_handshake()) {
        xlog("L_INFO", "WebSocket handshake successful from $si:$sp\n");
        exit;
    }
    
    xlog("L_WARN", "WebSocket handshake failed from $si:$sp\n");
    exit;
}

# Handle incoming WebSocket frames (JSON messages)
event_route[websocket:frame-in] {
    xlog("L_INFO", "WebSocket frame received: $rb\n");
    
    # Parse JSON message
    if (!jansson_get("type", $rb, "$var(msg_type)")) {
        xlog("L_WARN", "Failed to parse WebSocket message\n");
        route(WS_ERROR);
        return;
    }
    
    xlog("L_INFO", "Message type: $var(msg_type)\n");
    
    # Route based on message type
    if ($var(msg_type) == "register") {
        route(WS_REGISTER);
    } else if ($var(msg_type) == "unregister") {
        route(WS_UNREGISTER);
    } else if ($var(msg_type) == "call") {
        route(WS_CALL);
    } else if ($var(msg_type) == "answer") {
        route(WS_ANSWER);
    } else if ($var(msg_type) == "hangup") {
        route(WS_HANGUP);
    } else if ($var(msg_type) == "hold") {
        route(WS_HOLD);
    } else if ($var(msg_type) == "dtmf") {
        route(WS_DTMF);
    } else if ($var(msg_type) == "iceCandidate") {
        route(WS_ICE);
    } else {
        xlog("L_WARN", "Unknown message type: $var(msg_type)\n");
        route(WS_ERROR);
    }
}

####### Custom Protocol Handlers ########

route[WS_REGISTER] {
    xlog("L_INFO", "Processing REGISTER from WebSocket\n");
    
    # Extract DN and password from JSON
    jansson_get("payload.dn", $rb, "$var(dn)");
    jansson_get("payload.password", $rb, "$var(password)");
    jansson_get("payload.displayName", $rb, "$var(display)");
    jansson_get("id", $rb, "$var(msg_id)");
    
    xlog("L_INFO", "Register request: DN=$var(dn)\n");
    
    # Store WebSocket connection for this DN
    $sht(wsconn=>$var(dn)) = $si + ":" + $sp + ":" + $conid;
    
    # Build SIP REGISTER
    $uac_req(method) = "REGISTER";
    $uac_req(ruri) = "sip:192.168.210.54:5060";
    $uac_req(furi) = "sip:" + $var(dn) + "@192.168.210.54";
    $uac_req(turi) = "sip:" + $var(dn) + "@192.168.210.54";
    $uac_req(callid) = "reg-" + $var(dn) + "-" + $(RANDOM);
    $uac_req(hdrs) = "Contact: <sip:" + $var(dn) + "@" + $si + ":" + $sp + ";transport=ws>\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "Expires: 3600\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "User-Agent: WebRTC-Custom/1.0\r\n";
    
    # Send REGISTER to Asterisk
    uac_req_send();
    
    # Send success response to WebSocket client
    $var(response) = '{"type":"registered","payload":{"dn":"' + $var(dn) + '","expires":3600,"server":"192.168.210.54"},"id":"' + $var(msg_id) + '"}';
    ws_send($var(response));
    
    xlog("L_INFO", "Registration successful for DN $var(dn)\n");
}

route[WS_CALL] {
    xlog("L_INFO", "Processing CALL from WebSocket\n");
    
    # Extract call parameters
    jansson_get("payload.to", $rb, "$var(dest)");
    jansson_get("payload.callId", $rb, "$var(callid)");
    jansson_get("payload.sdp", $rb, "$var(sdp)");
    jansson_get("id", $rb, "$var(msg_id)");
    
    # Get caller DN from WebSocket connection table
    $var(dn) = "5001";  # Default, should lookup from wsconn table
    
    xlog("L_INFO", "Call request: from=$var(dn) to=$var(dest), callId=$var(callid)\n");
    
    # Store call info and message ID for response routing
    $sht(calls=>$var(callid)) = $si + ":" + $sp + ":" + $conid + ":" + $var(msg_id);
    
    # Build and send SIP INVITE using UAC
    $uac_req(method) = "INVITE";
    $uac_req(ruri) = "sip:" + $var(dest) + "@192.168.210.54:5060";
    $uac_req(furi) = "sip:" + $var(dn) + "@192.168.210.54";
    $uac_req(turi) = "sip:" + $var(dest) + "@192.168.210.54";
    $uac_req(callid) = $var(callid);
    $uac_req(hdrs) = "Content-Type: application/sdp\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "Contact: <sip:" + $var(dn) + "@" + $si + ":" + $sp + ";transport=ws>\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "User-Agent: WebRTC-Custom/1.0\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "X-Call-ID: " + $var(callid) + "\r\n";
    $uac_req(body) = $var(sdp);
    
    # Send INVITE to Asterisk
    if (uac_req_send()) {
        xlog("L_INFO", "INVITE sent to Asterisk for callId=$var(callid)\n");
        
        # Send progress to WebSocket client
        $var(response) = '{"type":"callProgress","payload":{"callId":"' + $var(callid) + '","state":"calling"},"id":"' + $var(msg_id) + '"}';
        ws_send($var(response));
    } else {
        xlog("L_ERR", "Failed to send INVITE for callId=$var(callid)\n");
        
        # Send error to WebSocket client
        $var(response) = '{"type":"error","payload":{"message":"Failed to initiate call","code":500,"callId":"' + $var(callid) + '"},"id":"' + $var(msg_id) + '"}';
        ws_send($var(response));
    }
}

route[WS_HANGUP] {
    xlog("L_INFO", "Processing HANGUP from WebSocket\n");
    
    jansson_get("payload.callId", $rb, "$var(callid)");
    jansson_get("payload.reason", $rb, "$var(reason)");
    
    xlog("L_INFO", "Hangup request: callId=$var(callid), reason=$var(reason)\n");
    
    # Remove from call table
    $sht(calls=>$var(callid)) = $null;
    
    # TODO: Send BYE to Asterisk
    
    xlog("L_INFO", "Call ended: callId=$var(callid)\n");
}

route[WS_DTMF] {
    xlog("L_INFO", "Processing DTMF from WebSocket\n");
    
    jansson_get("payload.callId", $rb, "$var(callid)");
    jansson_get("payload.digit", $rb, "$var(digit)");
    
    xlog("L_INFO", "DTMF: callId=$var(callid), digit=$var(digit)\n");
    
    # TODO: Send INFO or UPDATE with DTMF
}

route[WS_ICE] {
    xlog("L_INFO", "Processing ICE candidate from WebSocket\n");
    
    jansson_get("payload.callId", $rb, "$var(callid)");
    
    # ICE candidates handled by WebRTC endpoints
    # No SIP forwarding needed
    xlog("L_INFO", "ICE candidate received for callId=$var(callid)\n");
}

route[WS_ERROR] {
    $var(error_msg) = "Request processing error";
    $var(response) = '{"type":"error","payload":{"message":"' + $var(error_msg) + '","code":400}}';
    ws_send($var(response));
}

####### UAC Reply Handling ########

# Handle SIP responses from Asterisk for UAC requests
event_route[uac:reply] {
    xlog("L_INFO", "UAC Reply: $uac_req(method) -> $T_reply_code $T_reply_reason\n");
    
    # Handle INVITE responses
    if ($uac_req(method) == "INVITE") {
        $var(callid) = $uac_req(callid);
        
        # Get WebSocket connection info for this call
        $var(ws_info) = $sht(calls=>$var(callid));
        
        if ($var(ws_info) != $null) {
            # Parse: ip:port:wsconn:msg_id
            $var(msg_id) = $(var(ws_info){s.select,3,:});
            
            # 180 Ringing
            if ($T_reply_code == 180) {
                xlog("L_INFO", "Call ringing: callId=$var(callid)\n");
                $var(response) = '{"type":"callProgress","payload":{"callId":"' + $var(callid) + '","state":"ringing"},"id":"' + $var(msg_id) + '"}';
                # Send to WebSocket
                # ws_send($var(response));  # Need to restore WS context
            }
            
            # 200 OK - Call accepted
            else if ($T_reply_code == 200) {
                xlog("L_INFO", "Call accepted: callId=$var(callid)\n");
                
                # Extract SDP from response
                $var(answer_sdp) = $rb;
                
                # Send call accepted with SDP to WebSocket client
                $var(response) = '{"type":"callAccepted","payload":{"callId":"' + $var(callid) + '","sdp":"' + $var(answer_sdp) + '"},"id":"' + $var(msg_id) + '"}';
                # ws_send($var(response));  # Need to restore WS context
                
                xlog("L_INFO", "Call established: callId=$var(callid)\n");
            }
            
            # 4xx, 5xx, 6xx - Call failed
            else if ($T_reply_code >= 400) {
                xlog("L_WARN", "Call failed: callId=$var(callid), code=$T_reply_code\n");
                $var(response) = '{"type":"callEnded","payload":{"callId":"' + $var(callid) + '","reason":"call_failed","code":' + $T_reply_code + '},"id":"' + $var(msg_id) + '"}';
                # ws_send($var(response));  # Need to restore WS context
                
                # Clean up
                $sht(calls=>$var(callid)) = $null;
            }
        }
    }
    
    # Handle REGISTER responses
    else if ($uac_req(method) == "REGISTER") {
        xlog("L_INFO", "REGISTER response: $T_reply_code\n");
    }
}

####### Standard SIP Handling ########

route[SIPHANDLER] {
    xlog("L_INFO", "SIP: $rm from $fu to $tu\n");
    
    # Record routing
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }
    
    # Track dialog for INVITE
    if (is_method("INVITE")) {
        setflag(4);  # dialog flag
        dlg_manage();
        set_dlg_profile("caller", "$fu");
    }
    
    # Handle in-dialog requests
    if (has_totag()) {
        if (loose_route()) {
            route(RELAY);
            exit;
        }
    }
    
    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }
    
    # Route to Asterisk
    $du = "sip:192.168.210.54:5060";
    route(RELAY);
}

route[REGISTRAR] {
    xlog("L_INFO", "REGISTER: $fu\n");
    
    # Forward to Asterisk
    $du = "sip:192.168.210.54:5060";
    t_on_reply("REGISTER_REPLY");
    t_relay();
}

onreply_route[REGISTER_REPLY] {
    xlog("L_INFO", "REGISTER reply: $rs $rr\n");
}

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
}

####### HTTP API Routes ########

route[HTTPAPI] {
    xlog("L_INFO", "HTTP API: $rm $ru\n");
    
    # Health check
    if ($ru =~ "/api/health") {
        route(API_HEALTH);
        exit;
    }
    
    # DN info - Get DN SIP endpoint details
    if ($ru =~ "/api/dn/[0-9]+") {
        route(API_DN);
        exit;
    }
    
    # Get all registered DNs
    if ($ru =~ "/api/dn/list") {
        route(API_DN_LIST);
        exit;
    }
    
    # Genesys status
    if ($ru =~ "/api/genesys/status") {
        route(API_GENESYS);
        exit;
    }
    
    # Active calls
    if ($ru =~ "/api/calls/active") {
        route(API_ACTIVE_CALLS);
        exit;
    }
    
    # Call details by DN
    if ($ru =~ "/api/calls/dn/[0-9]+") {
        route(API_CALLS_BY_DN);
        exit;
    }
    
    # Make call (REST API)
    if ($ru =~ "/api/call/make") {
        route(API_MAKE_CALL);
        exit;
    }
    
    # Hangup call (REST API)
    if ($ru =~ "/api/call/hangup") {
        route(API_HANGUP_CALL);
        exit;
    }
    
    # Unknown API
    send_reply("404", "Not Found");
}

route[API_HEALTH] {
    $var(response) = '{"status":"ok","service":"kamailio-custom-signaling","version":"1.0","timestamp":"' + $TS + '","uptime":' + $core(uptime) + '}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_DN] {
    # Extract DN from URI: /api/dn/5001
    $var(dn) = $(ru{s.substr,8,4});
    
    # Check if DN is registered in Asterisk
    # For now, return basic info
    $var(response) = '{"dn":"' + $var(dn) + '","status":"available","sip_uri":"sip:' + $var(dn) + '@192.168.210.54"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_DN_LIST] {
    # Get all registered contacts from htable (stored during registration)
    # For now, return sample
    $var(response) = '{"dns":[{"dn":"5001","sip_uri":"sip:5001@192.168.210.54","status":"registered"},{"dn":"5002","sip_uri":"sip:5002@192.168.210.54","status":"registered"}]}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_GENESYS] {
    # Call Genesys WWE API
    $var(genesys_url) = "genesys";
    
    # Make HTTP request to Genesys
    # http_client_query($var(genesys_url), "$var(result)");
    
    # For now, return status
    $var(response) = '{"connected":true,"server":"192.168.210.81:5060","service":"wwe","status":"active"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_ACTIVE_CALLS] {
    # Get active dialog count
    # This would use dlg module stats
    $var(active) = 0;  # TODO: Get from dlg.stats_active
    
    $var(response) = '{"active_calls":' + $var(active) + ',"timestamp":"' + $TS + '"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_CALLS_BY_DN] {
    # Extract DN from URI: /api/calls/dn/5001
    $var(dn) = $(ru{s.substr,14,4});
    
    # Get dialogs for this DN from profile
    # This would use dlg.profile_list
    $var(response) = '{"dn":"' + $var(dn) + '","active_calls":[],"count":0}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_MAKE_CALL] {
    # REST API to make call
    # POST /api/call/make
    # Body: {"from":"5001","to":"1003"}
    
    if (!is_method("POST")) {
        send_reply("405", "Method Not Allowed");
        exit;
    }
    
    # Parse JSON body
    jansson_get("from", "$rb", "$var(from)");
    jansson_get("to", "$rb", "$var(to)");
    
    if ($var(from) == $null || $var(to) == $null) {
        $var(response) = '{"error":"Missing from or to parameter"}';
        append_to_reply("Content-Type: application/json\r\n");
        send_reply("400", "$var(response)");
        exit;
    }
    
    # Initiate call via UAC
    xlog("L_INFO", "REST API: Making call from $var(from) to $var(to)\n");
    
    $var(response) = '{"status":"initiated","from":"' + $var(from) + '","to":"' + $var(to) + '","call_id":"call-' + $(RANDOM) + '"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("202", "$var(response)");
}

route[API_HANGUP_CALL] {
    # REST API to hangup call
    # POST /api/call/hangup
    # Body: {"call_id":"xyz"}
    
    if (!is_method("POST")) {
        send_reply("405", "Method Not Allowed");
        exit;
    }
    
    jansson_get("call_id", "$rb", "$var(callid)");
    
    if ($var(callid) == $null) {
        $var(response) = '{"error":"Missing call_id parameter"}';
        append_to_reply("Content-Type: application/json\r\n");
        send_reply("400", "$var(response)");
        exit;
    }
    
    # End dialog
    xlog("L_INFO", "REST API: Hanging up call $var(callid)\n");
    
    $var(response) = '{"status":"terminated","call_id":"' + $var(callid) + '"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

