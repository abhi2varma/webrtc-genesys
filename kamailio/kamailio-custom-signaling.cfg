#!KAMAILIO
#
# Kamailio - Custom WebRTC Signaling Server
# Purpose: Convert JSON WebSocket messages → SIP
# Architecture: Browser (Custom Protocol) → Kamailio → Asterisk → Genesys
#

####### Global Parameters #########

debug=3
log_stderror=yes
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

fork=yes
children=4

# TCP settings
disable_tcp=no
tcp_children=4
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

# Listen interfaces
listen=udp:192.168.210.54:5070
listen=tcp:192.168.210.54:5070
listen=tcp:192.168.210.54:8080

# Aliases
alias=192.168.210.54

# Server header
server_signature=no
user_agent_header="User-Agent: Kamailio Custom Signaling"

####### Modules Section ########

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"

# Authentication
loadmodule "auth.so"

# NAT traversal
loadmodule "usrloc.so"
loadmodule "nathelper.so"

# WebSocket
loadmodule "websocket.so"
loadmodule "xhttp.so"

# Path support
loadmodule "path.so"

# JSON and HTTP
loadmodule "jansson.so"
loadmodule "http_client.so"
loadmodule "htable.so"

# SDP manipulation
loadmodule "sdpops.so"

# JSON RPC for API
loadmodule "jsonrpcs.so"

# UAC (User Agent Client) for generating requests
loadmodule "uac.so"

####### Module Parameters ########

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 0)

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# ----- path params -----
modparam("path", "use_received", 1)

# ----- jansson params -----
# JSON parsing for custom protocol

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 7)

# ----- http_client params -----
modparam("http_client", "httpcon", "genesys=>http://192.168.210.81:8080/api")
modparam("http_client", "connection_timeout", 2)

# ----- htable params -----
# Store WebSocket connection info by DN
modparam("htable", "htable", "wsconn=>size=8;autoexpire=3600")
# Store call info by call ID
modparam("htable", "htable", "calls=>size=16;autoexpire=7200")

# ----- uac params -----
modparam("uac", "reg_db_url", "")
modparam("uac", "restore_mode", "auto")

####### Routing Logic ########

request_route {
    # Per-request initial checks
    route(REQINIT);
    
    # WebSocket requests
    if (is_method("GET") && $hdr(Upgrade) =~ "websocket") {
        xlog("L_INFO", "WebSocket connection request\n");
        route(WEBSOCKET);
        exit;
    }
    
    # HTTP API requests
    if (is_method("GET|POST") && $hdr(Content-Type) =~ "application/json") {
        xlog("L_INFO", "HTTP API request: $rm $ru\n");
        route(HTTPAPI);
        exit;
    }
    
    # Standard SIP routing
    route(SIPHANDLER);
}

####### Helper Routes ########

route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }
    
    # Sanity checks
    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }
}

####### WebSocket Handling ########

route[WEBSOCKET] {
    if (ws_handle_handshake()) {
        xlog("L_INFO", "WebSocket handshake successful from $si:$sp\n");
        exit;
    }
    
    xlog("L_WARN", "WebSocket handshake failed from $si:$sp\n");
    exit;
}

# Handle incoming WebSocket frames (JSON messages)
event_route[websocket:frame-in] {
    xlog("L_INFO", "WebSocket frame received: $ws.data\n");
    
    # Parse JSON message
    if (!jansson_get("type", $ws.data, "$var(msg_type)")) {
        xlog("L_WARN", "Failed to parse WebSocket message\n");
        route(WS_ERROR, "Invalid JSON");
        return;
    }
    
    xlog("L_INFO", "Message type: $var(msg_type)\n");
    
    # Route based on message type
    if ($var(msg_type) == "register") {
        route(WS_REGISTER);
    } else if ($var(msg_type) == "unregister") {
        route(WS_UNREGISTER);
    } else if ($var(msg_type) == "call") {
        route(WS_CALL);
    } else if ($var(msg_type) == "answer") {
        route(WS_ANSWER);
    } else if ($var(msg_type) == "hangup") {
        route(WS_HANGUP);
    } else if ($var(msg_type) == "hold") {
        route(WS_HOLD);
    } else if ($var(msg_type) == "dtmf") {
        route(WS_DTMF);
    } else if ($var(msg_type) == "iceCandidate") {
        route(WS_ICE);
    } else {
        xlog("L_WARN", "Unknown message type: $var(msg_type)\n");
        route(WS_ERROR, "Unknown message type");
    }
}

####### Custom Protocol Handlers ########

route[WS_REGISTER] {
    xlog("L_INFO", "Processing REGISTER from WebSocket\n");
    
    # Extract DN and password from JSON
    jansson_get("payload.dn", $ws.data, "$var(dn)");
    jansson_get("payload.password", $ws.data, "$var(password)");
    jansson_get("payload.displayName", $ws.data, "$var(display)");
    jansson_get("id", $ws.data, "$var(msg_id)");
    
    xlog("L_INFO", "Register request: DN=$var(dn)\n");
    
    # Store WebSocket connection for this DN
    $sht(wsconn=>$var(dn)) = $si + ":" + $sp + ":" + $wsc;
    
    # Build SIP REGISTER
    $uac_req(method) = "REGISTER";
    $uac_req(ruri) = "sip:192.168.210.54:5060";
    $uac_req(furi) = "sip:" + $var(dn) + "@192.168.210.54";
    $uac_req(turi) = "sip:" + $var(dn) + "@192.168.210.54";
    $uac_req(callid) = "reg-" + $var(dn) + "-" + $RANDOM;
    $uac_req(hdrs) = "Contact: <sip:" + $var(dn) + "@" + $si + ":" + $sp + ";transport=ws>\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "Expires: 3600\r\n";
    $uac_req(hdrs) = $uac_req(hdrs) + "User-Agent: WebRTC-Custom/1.0\r\n";
    
    # Send REGISTER to Asterisk
    uac_req_send();
    
    # Send success response to WebSocket client
    $var(response) = '{"type":"registered","payload":{"dn":"' + $var(dn) + '","expires":3600,"server":"192.168.210.54"},"id":"' + $var(msg_id) + '"}';
    ws_send($var(response));
    
    xlog("L_INFO", "Registration successful for DN $var(dn)\n");
}

route[WS_CALL] {
    xlog("L_INFO", "Processing CALL from WebSocket\n");
    
    # Extract call parameters
    jansson_get("payload.to", $ws.data, "$var(dest)");
    jansson_get("payload.callId", $ws.data, "$var(callid)");
    jansson_get("payload.sdp", $ws.data, "$var(sdp)");
    jansson_get("id", $ws.data, "$var(msg_id)");
    
    xlog("L_INFO", "Call request: to=$var(dest), callId=$var(callid)\n");
    
    # Store call info
    $sht(calls=>$var(callid)) = $si + ":" + $sp + ":" + $wsc + ":" + $var(dest);
    
    # Build SIP INVITE
    # TODO: Convert JSON to full SIP INVITE with SDP
    # For now, acknowledge receipt
    $var(response) = '{"type":"callProgress","payload":{"callId":"' + $var(callid) + '","state":"ringing"},"id":"' + $var(msg_id) + '"}';
    ws_send($var(response));
    
    xlog("L_INFO", "Call initiated: callId=$var(callid)\n");
}

route[WS_HANGUP] {
    xlog("L_INFO", "Processing HANGUP from WebSocket\n");
    
    jansson_get("payload.callId", $ws.data, "$var(callid)");
    jansson_get("payload.reason", $ws.data, "$var(reason)");
    
    xlog("L_INFO", "Hangup request: callId=$var(callid), reason=$var(reason)\n");
    
    # Remove from call table
    $sht(calls=>$var(callid)) = $null;
    
    # TODO: Send BYE to Asterisk
    
    xlog("L_INFO", "Call ended: callId=$var(callid)\n");
}

route[WS_DTMF] {
    xlog("L_INFO", "Processing DTMF from WebSocket\n");
    
    jansson_get("payload.callId", $ws.data, "$var(callid)");
    jansson_get("payload.digit", $ws.data, "$var(digit)");
    
    xlog("L_INFO", "DTMF: callId=$var(callid), digit=$var(digit)\n");
    
    # TODO: Send INFO or UPDATE with DTMF
}

route[WS_ICE] {
    xlog("L_INFO", "Processing ICE candidate from WebSocket\n");
    
    jansson_get("payload.callId", $ws.data, "$var(callid)");
    
    # ICE candidates handled by WebRTC endpoints
    # No SIP forwarding needed
    xlog("L_INFO", "ICE candidate received for callId=$var(callid)\n");
}

route[WS_ERROR] {
    $var(error_msg) = $param(1);
    $var(response) = '{"type":"error","payload":{"message":"' + $var(error_msg) + '","code":400}}';
    ws_send($var(response));
}

####### Standard SIP Handling ########

route[SIPHANDLER] {
    xlog("L_INFO", "SIP: $rm from $fu to $tu\n");
    
    # Record routing
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }
    
    # Handle in-dialog requests
    if (has_totag()) {
        if (loose_route()) {
            route(RELAY);
            exit;
        }
    }
    
    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }
    
    # Route to Asterisk
    $du = "sip:192.168.210.54:5060";
    route(RELAY);
}

route[REGISTRAR] {
    xlog("L_INFO", "REGISTER: $fu\n");
    
    # Forward to Asterisk
    $du = "sip:192.168.210.54:5060";
    t_on_reply("REGISTER_REPLY");
    t_relay();
}

onreply_route[REGISTER_REPLY] {
    xlog("L_INFO", "REGISTER reply: $rs $rr\n");
}

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
}

####### HTTP API Routes ########

route[HTTPAPI] {
    xlog("L_INFO", "HTTP API: $rm $ru\n");
    
    # Health check
    if ($ru =~ "/api/health") {
        route(API_HEALTH);
        exit;
    }
    
    # DN info
    if ($ru =~ "/api/dn/") {
        route(API_DN);
        exit;
    }
    
    # Genesys status
    if ($ru =~ "/api/genesys/status") {
        route(API_GENESYS);
        exit;
    }
    
    # Unknown API
    send_reply("404", "Not Found");
}

route[API_HEALTH] {
    $var(response) = '{"status":"ok","server":"kamailio","timestamp":"' + $TS + '"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_DN] {
    # Extract DN from URI
    $var(dn) = $(ru{s.substr,8,4});
    
    $var(response) = '{"dn":"' + $var(dn) + '","status":"available"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

route[API_GENESYS] {
    $var(response) = '{"connected":true,"server":"192.168.210.81:5060"}';
    append_to_reply("Content-Type: application/json\r\n");
    send_reply("200", "$var(response)");
}

