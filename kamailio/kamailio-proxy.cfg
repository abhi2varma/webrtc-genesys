#!KAMAILIO
#
# Kamailio SIP Proxy - WebRTC Gateway Configuration
# Purpose: SIP proxy with WebSocket, Authentication, NAT detection, and Routing
# Architecture: Browser (WSS) → Kamailio → Asterisk (UDP) → Genesys
#

####### Global Parameters #########

# Debug level
debug=3
log_stderror=yes
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

fork=yes
children=4

# TCP settings
disable_tcp=no
tcp_children=4
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

# Listen interfaces
# Using different ports to avoid conflict with Asterisk (which uses 5060)
listen=udp:192.168.210.54:5070
listen=tcp:192.168.210.54:5070
listen=tcp:192.168.210.54:8080
listen=tls:192.168.210.54:5071
listen=tls:192.168.210.54:8443

# Aliases
alias=192.168.210.54
alias=webrtc.genesys.local

# TLS config
enable_tls=yes

# Server header
server_signature=no
user_agent_header="User-Agent: Kamailio WebRTC Proxy"

####### Modules Section ########

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"

# Authentication - handled by Asterisk backend
# Future: enable for centralized auth
# loadmodule "auth.so"
# loadmodule "auth_db.so"

# NAT traversal
loadmodule "usrloc.so"
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"

# WebSocket
loadmodule "websocket.so"
loadmodule "xhttp.so"

# TLS
loadmodule "tls.so"

# Database (for authentication)
# Using text file for simplicity - production should use database
loadmodule "permissions.so"

# Dispatcher (for Asterisk backends)
loadmodule "dispatcher.so"

# JSON and HTTP client (for API calls)
loadmodule "json.so"
loadmodule "http_client.so"

####### Module Parameters ########

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- auth_db params -----
# Authentication disabled for initial testing - Asterisk will handle auth
# Production should enable this with proper database backend

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 0)
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

# ----- rtpproxy params -----
# Note: We're NOT using rtpproxy for media relay
# Asterisk handles all media (DTLS-SRTP ↔ RTP)
# rtpproxy module loaded but not actively used

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "ping_application_data", "PING from Kamailio")

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")

# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_from", "sip:kamailio@192.168.210.54")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_probing_threshold", 3)

####### Routing Logic ########

request_route {
    # Per-request initial checks
    route(REQINIT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1);
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # User location lookup
    if ($rU == $null) {
        sl_send_reply("484", "Address Incomplete");
        exit;
    }

    # Authenticate requests
    route(AUTH);

    # Handle presence
    if (is_method("SUBSCRIBE|PUBLISH")) {
        route(PRESENCE);
        exit;
    }

    # Dispatch to Asterisk
    route(DISPATCH);
}

####### Helper Routes ########

# Request initial sanity checks
route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Sanity checks
    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # OPTIONS keepalive
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    # WebSocket handling
    if (nat_uac_test("64")) {
        # WebSocket connection - force record-route
        force_rport();
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (!add_contact_alias()) {
                xlog("L_ERR", "Error aliasing contact <$ct>\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request - sanity check
    if (!loose_route()) {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply("404", "Not Found");
        exit;
    } else {
        if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
    }
    exit;
}

# REGISTER processing
route[REGISTRAR] {
    xlog("L_INFO", "REGISTER from $fu (contact: $ct)\n");

    # NAT detection
    if (nat_uac_test("19")) {
        xlog("L_INFO", "NAT detected for $fu from $si:$sp\n");
        setbflag(6);
        fix_nated_register();
    }

    # For WebSocket clients, force contact rewriting
    if ($pr =~ "ws" || $pr =~ "wss") {
        xlog("L_INFO", "WebSocket REGISTER from $fu\n");
        setbflag(8);
        fix_nated_register();
    }

    # Forward to Asterisk for registration and authentication
    if (!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    # Set outbound proxy
    $du = "sip:127.0.0.1:5060;transport=udp";

    xlog("L_INFO", "Forwarding REGISTER to Asterisk: $du\n");
    
    t_on_reply("REGISTER_REPLY");
    route(RELAY);
}

# Authentication
route[AUTH] {
    # Authentication handled by Asterisk backend
    # Kamailio acts as transparent proxy for auth
    # Future: implement centralized auth here
    xlog("L_INFO", "AUTH: Passing request to Asterisk for authentication\n");
    return;
}

# Presence handling
route[PRESENCE] {
    xlog("L_INFO", "PRESENCE: $rm from $fu to $tu\n");
    
    # Forward to Asterisk
    if (!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    $du = "sip:127.0.0.1:5060;transport=udp";
    route(RELAY);
}

# Dispatch to Asterisk backends
route[DISPATCH] {
    xlog("L_INFO", "DISPATCH: $rm from $fu to $ru\n");

    # NAT detection for requests
    route(NATDETECT);

    # Select Asterisk backend
    if (!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    # Force destination to Asterisk
    $du = "sip:127.0.0.1:5060;transport=udp";

    xlog("L_INFO", "Routing to Asterisk: $du (method: $rm, from: $fu, to: $ru)\n");

    # Enable failure route
    t_on_failure("DISPATCH_FAILURE");
    t_on_reply("DISPATCH_REPLY");

    route(RELAY);
}

# NAT detection
route[NATDETECT] {
    force_rport();
    
    if (nat_uac_test("19")) {
        xlog("L_INFO", "NAT detected: $si:$sp\n");
        setflag(5);
        
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if ($pr =~ "ws") {
                if (!add_contact_alias()) {
                    xlog("L_ERR", "Error adding contact alias\n");
                }
            } else {
                fix_nated_contact();
            }
        }
    }

    # WebSocket always needs contact aliasing
    if ($pr =~ "ws") {
        setflag(5);
        setbflag(8);
    }
}

# Relay route
route[RELAY] {
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    
    if (is_method("INVITE")) {
        if (!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

####### Branch Route ########

branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "New branch [$T_branch_idx] to $ru\n");
    
    if ($pr =~ "ws") {
        xlog("L_INFO", "Branch is WebSocket\n");
    }
}

####### Reply Routes ########

onreply_route[REGISTER_REPLY] {
    xlog("L_INFO", "REGISTER reply: $rs $rr from Asterisk\n");
    
    if (status =~ "^[12][0-9][0-9]" && $pr =~ "ws") {
        xlog("L_INFO", "WebSocket REGISTER reply handled\n");
    }
}

onreply_route[DISPATCH_REPLY] {
    xlog("L_INFO", "Reply: $rs $rr (method: $rm)\n");
    
    # NAT management for WebSocket
    if (isbflagset(8) && status =~ "^[12][0-9][0-9]") {
        if ($pr =~ "ws") {
            xlog("L_INFO", "WebSocket reply handled\n");
        }
    }
}

onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "Managing reply: $rs $rr\n");
    
    if (status =~ "^[12][0-9][0-9]") {
        if (isbflagset(8) && $pr =~ "ws") {
            xlog("L_INFO", "WebSocket reply - contact alias managed\n");
        }
    }
}

####### Failure Route ########

failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    xlog("L_INFO", "Transaction failed: $rs $rr\n");
}

failure_route[DISPATCH_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    xlog("L_WARN", "Dispatch failed: $rs $rr - trying next Asterisk\n");

    # Try next Asterisk instance
    if (ds_next_dst()) {
        xlog("L_INFO", "Trying next destination: $du\n");
        t_on_failure("DISPATCH_FAILURE");
        route(RELAY);
        exit;
    }

    xlog("L_ERR", "All Asterisk backends failed\n");
}

####### Event Routes ########

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection closed from $si:$sp\n");
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp != 8080 && $Rp != 8443 && $Rp != 5060) {
        xlog("L_WARN", "HTTP request to wrong port $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    xlog("L_INFO", "HTTP Request: $rm $hu from $si:$sp\n");

    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
        # WebSocket handshake
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake successful\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake failed\n");
            xhttp_reply("400", "Bad Request", "", "");
            exit;
        }
    }

    xhttp_reply("200", "OK", "text/html", "<html><body><h1>Kamailio WebRTC Proxy</h1><p>WebSocket endpoint: ws://192.168.210.54:8080/ws or wss://192.168.210.54:8443/ws</p></body></html>");
}


