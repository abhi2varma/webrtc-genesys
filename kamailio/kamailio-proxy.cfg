#!KAMAILIO
#
# Kamailio SIP Proxy - WebRTC Gateway Configuration
# Purpose: SIP proxy with WebSocket, Authentication, NAT detection, and Routing
# Architecture: Browser (WSS) ‚Üí Kamailio ‚Üí Asterisk (UDP) ‚Üí Genesys
#

####### Global Parameters #########

# Debug level
debug=4
log_stderror=yes
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

fork=yes
children=4

# TCP settings
disable_tcp=no
tcp_children=4
tcp_accept_no_cl=yes
tcp_connection_lifetime=3605

# Listen interfaces
# Using different ports to avoid conflict with Asterisk (which uses 5060)
listen=udp:192.168.210.54:5070
listen=tcp:192.168.210.54:5070
listen=tcp:192.168.210.54:8080
# TLS/WSS disabled - Nginx handles HTTPS/WSS and proxies to port 8080
#listen=tls:192.168.210.54:5071
#listen=tls:192.168.210.54:8443

# Aliases
alias=192.168.210.54
alias=webrtc.genesys.local

# TLS config - disabled (Nginx handles HTTPS/WSS)
#enable_tls=yes

# Server header
server_signature=no
user_agent_header="User-Agent: Kamailio WebRTC Proxy"

####### Modules Section ########

# Core modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"

# Authentication modules
loadmodule "auth.so"

# NAT traversal
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# WebSocket
loadmodule "websocket.so"
loadmodule "xhttp.so"

# TLS - disabled (Nginx handles HTTPS/WSS)
#loadmodule "tls.so"

# Database (for authentication)
# Using text file for simplicity - production should use database
loadmodule "permissions.so"

# Path support (for WebSocket registration through proxy)
loadmodule "path.so"

# Dispatcher (for Asterisk backends)
loadmodule "dispatcher.so"

# JSON and HTTP client (for API calls)
loadmodule "json.so"
loadmodule "http_client.so"

# Dialog tracking (for live call monitoring)
loadmodule "dialog.so"

# UAC (for sending REGISTER to Genesys)
loadmodule "uac.so"

####### Module Parameters ########

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- auth_db params -----
# Authentication disabled for initial testing - Asterisk will handle auth
# Production should enable this with proper database backend

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "nat_bflag", 6)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 0)
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

# ----- rtpengine params -----
# Media relay for WebRTC <-> SIP behind NAT
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "ping_application_data", "PING from Kamailio")

# ----- tls params -----
# TLS disabled - Nginx handles HTTPS/WSS
#modparam("tls", "config", "/etc/kamailio/tls.cfg")

# ----- path params -----
modparam("path", "use_received", 1)

# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
# Disable OPTIONS probing - Asterisk requires authentication
# We're in host mode with single Asterisk, no health check needed
modparam("dispatcher", "ds_probing_mode", 0)
# modparam("dispatcher", "ds_ping_interval", 10)
# modparam("dispatcher", "ds_ping_from", "sip:kamailio@192.168.210.54")
# modparam("dispatcher", "ds_probing_threshold", 3)

# ----- dialog params -----
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "timeout_avp", "$avp(dlg_timeout)")
modparam("dialog", "default_timeout", 21600)  # 6 hours
modparam("dialog", "dlg_extra_hdrs", "X-Kamailio-Dialog: yes\r\n")
# Enable dialog statistics
modparam("dialog", "track_cseq_updates", 1)
# Profiles for monitoring
modparam("dialog", "profiles_with_value", "caller")

####### Routing Logic ########

request_route {
    # Per-request initial checks
    route(REQINIT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1);
        # Track dialog for monitoring
        setflag(4);  # dialog flag
        dlg_manage();
        # Add to caller profile for statistics
        set_dlg_profile("caller", "$fu");
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Bypass authentication for trusted sources (Asterisk) - MUST come before $rU null check
    # Allow both 192.168.210.54 (Genesys->Asterisk) and 127.0.0.1 (Asterisk outbound_proxy)
    if ($si == "192.168.210.54" || $si == "127.0.0.1") {
        xlog("L_INFO", "‚úÖ Trusted source: Asterisk ($si:$sp) - bypassing auth for $rm to $ru\n");
        xlog("L_INFO", "Request-URI before lookup: $ru, Request-URI User: $rU, To-User: $tU\n");
        
        # Check if destination is a registered WebSocket client
        if (lookup("location")) {
            xlog("L_INFO", "‚úÖ lookup() SUCCESS! Routing from Asterisk to registered client: $ru\n");
            
            # Apply RTPengine for media relay
            if (is_method("INVITE") && has_body("application/sdp")) {
                xlog("L_INFO", "Calling MEDIA_OFFER route for RTPengine\n");
                route(MEDIA_OFFER);
            }
            
            route(RELAY);
            exit;
        }
        
        # If not found in location, route to Asterisk (shouldn't happen)
        xlog("L_WARN", "‚ùå lookup() FAILED! Client not found in location table. Routing to Asterisk.\n");
        route(DISPATCH);
        exit;
    }

    # User location lookup - only for non-trusted sources
    if ($rU == $null) {
        sl_send_reply("484", "Address Incomplete");
        exit;
    }

    # Authenticate requests
    route(AUTH);

    # Handle presence
    if (is_method("SUBSCRIBE|PUBLISH")) {
        route(PRESENCE);
        exit;
    }

    # Dispatch to Asterisk
    route(DISPATCH);
}

####### Helper Routes ########

# Request initial sanity checks
route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # Sanity checks
    if (!sanity_check("1511", "7")) {
        xlog("L_WARN", "Malformed SIP message from $si:$sp\n");
        exit;
    }

    # OPTIONS keepalive
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    # WebSocket handling
    if (nat_uac_test("64")) {
        # WebSocket connection - force record-route
        force_rport();
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (!add_contact_alias()) {
                xlog("L_ERR", "Error aliasing contact <$ct>\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request - sanity check
    if (!loose_route()) {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            } else {
                exit;
            }
        }
        sl_send_reply("404", "Not Found");
        exit;
    } else {
        if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
    }
    exit;
}

# REGISTER processing
route[REGISTRAR] {
    xlog("L_INFO", "REGISTER from $fu (contact: $ct)\n");

    # NAT detection
    if (nat_uac_test("19")) {
        xlog("L_INFO", "NAT detected for $fu from $si:$sp\n");
        setbflag(6);
        fix_nated_register();
    }

    # For WebSocket clients, force contact rewriting
    if ($pr =~ "ws" || $pr =~ "wss") {
        xlog("L_INFO", "WebSocket REGISTER from $fu\n");
        setbflag(8);
        fix_nated_register();
    }

    # ========================================
    # REGISTRATION STRATEGY:
    # Forward REGISTER to Genesys SIP Server directly (like SIP Endpoint does)
    # Asterisk will handle media/RTP but NOT registration
    # ========================================
    
    # Check if this is initial REGISTER or authenticated REGISTER
    if (!is_present_hf("Authorization") && !is_present_hf("Proxy-Authorization")) {
        # Initial REGISTER - forward to Asterisk for 401 challenge
        $du = "sip:192.168.210.54:5060;transport=udp";
        xlog("L_INFO", "Initial REGISTER - forwarding to Asterisk for auth challenge\n");
        t_on_reply("ASTERISK_AUTH_REPLY");
        route(RELAY);
        exit;
    }
    
    # Authenticated REGISTER - validate with Asterisk first, then forward to Genesys
    xlog("L_INFO", "Authenticated REGISTER - validating with Asterisk then forwarding to Genesys\n");
    
    # Extract DN from From header
    $var(dn) = $fU;
    
    # CRITICAL: Save the WebSocket client registration in Kamailio's location table
    # This allows lookup() to find the client when Asterisk sends INVITEs
    if (!save("location")) {
        xlog("L_ERR", "Failed to save registration in location table\n");
    } else {
        xlog("L_INFO", "‚úÖ Saved WebSocket registration for $fu (DN: $var(dn)) in location table\n");
    }
    
    # CRITICAL FIX: Rewrite Contact to use DN instead of WebSocket connection ID
    # This ensures Asterisk sends INVITEs with Request-URI sip:1002@... instead of sip:glmeb9ki@...
    # Kamailio will then be able to lookup() the DN and route to the WebSocket client
    $var(new_contact) = "<sip:" + $var(dn) + "@192.168.210.54:5070>";
    remove_hf("Contact");
    append_hf("Contact: $var(new_contact)\r\n");
    xlog("L_INFO", "Rewrote Contact to: $var(new_contact) for Asterisk registration\n");
    
    # Forward to Asterisk for authentication validation (synchronous)
    $du = "sip:192.168.210.54:5060;transport=udp";
    t_on_reply("ASTERISK_REGISTER_REPLY");
    route(RELAY);
}

# Authentication
route[AUTH] {
    # Authentication handled by Asterisk backend
    # Kamailio acts as transparent proxy for auth
    # Future: implement centralized auth here
    xlog("L_INFO", "AUTH: Passing request to Asterisk for authentication\n");
    return;
}

# Presence handling
route[PRESENCE] {
    xlog("L_INFO", "PRESENCE: $rm from $fu to $tu\n");
    
    # Forward to Asterisk
    if (!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    $du = "sip:192.168.210.54:5060;transport=udp";
    route(RELAY);
}

# Dispatch to Asterisk backends
route[DISPATCH] {
    xlog("L_INFO", "DISPATCH: $rm from $fu to $ru\n");

    # NAT detection for requests
    route(NATDETECT);

    # Select Asterisk backend
    if (!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    # Force destination to Asterisk
    $du = "sip:192.168.210.54:5060;transport=udp";

    xlog("L_INFO", "Routing to Asterisk: $du (method: $rm, from: $fu, to: $ru)\n");

    # Enable failure route
    t_on_failure("DISPATCH_FAILURE");
    t_on_reply("DISPATCH_REPLY");

    route(RELAY);
}

# NAT detection
route[NATDETECT] {
    force_rport();
    
    if (nat_uac_test("19")) {
        xlog("L_INFO", "NAT detected: $si:$sp\n");
        setflag(5);
        
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if ($pr =~ "ws") {
                if (!add_contact_alias()) {
                    xlog("L_ERR", "Error adding contact alias\n");
                }
            } else {
                fix_nated_contact();
            }
        }
    }

    # WebSocket always needs contact aliasing
    if ($pr =~ "ws") {
        setflag(5);
        setbflag(8);
    }
}

# Relay route
route[RELAY] {
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
        }
    }
    
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (!t_is_set("onreply_route")) {
            t_on_reply("MANAGE_REPLY");
        }
    }
    
    if (is_method("INVITE")) {
        if (!t_is_set("failure_route")) {
            t_on_failure("MANAGE_FAILURE");
        }
    }

    if (is_method("INVITE|UPDATE") && has_body("application/sdp")) {
        route(MEDIA_OFFER);
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Media handling (RTPengine)
route[MEDIA_OFFER] {
    xlog("L_INFO", "üéØ MEDIA_OFFER: Calling rtpengine_offer()...\n");
    # Anchor media and fix SDP/ICE candidates for NAT traversal
    if (!rtpengine_offer("replace-origin replace-session-connection ICE=force DTLS=passive RTP/SAVPF")) {
        xlog("L_ERR", "‚ùå RTPengine offer failed\n");
        send_reply("500", "RTPengine error");
        exit;
    }
    xlog("L_INFO", "‚úÖ RTPengine offer succeeded\n");
}

####### Branch Route ########

branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "New branch [$T_branch_idx] to $ru\n");
    
    if ($pr =~ "ws") {
        xlog("L_INFO", "Branch is WebSocket\n");
    }
}

####### Reply Routes ########

onreply_route[REGISTER_REPLY] {
    xlog("L_INFO", "REGISTER reply: $rs $rr from Asterisk\n");
    
    if (status =~ "^[12][0-9][0-9]" && $pr =~ "ws") {
        xlog("L_INFO", "WebSocket REGISTER reply handled\n");
    }
}

onreply_route[ASTERISK_AUTH_REPLY] {
    xlog("L_INFO", "Asterisk AUTH reply: $rs $rr\n");
    # Just pass the 401 Unauthorized back to the client
}

onreply_route[ASTERISK_REGISTER_REPLY] {
    xlog("L_INFO", "Asterisk REGISTER reply: $rs $rr\n");
    
    if (status == "200") {
        xlog("L_INFO", "Asterisk accepted REGISTER - now forwarding to Genesys\n");
        
        # Extract DN from From header
        $var(dn) = $fU;
        $var(genesys_uri) = "sip:" + $var(dn) + "@192.168.210.81:5061";
        
        # IMPORTANT: Rewrite Contact to Asterisk server address on port 5061
        # This ensures Genesys routes calls back to Asterisk on the Genesys-facing port
        $var(asterisk_contact) = "<sip:" + $var(dn) + "@192.168.210.54:5061>";
        
        # Send REGISTER to Genesys using uac_req_send
        $uac_req(method) = "REGISTER";
        $uac_req(ruri) = $var(genesys_uri);
        $uac_req(furi) = $fu;
        $uac_req(turi) = "sip:" + $var(dn) + "@192.168.210.81:5061";
        
        # Use rewritten Contact header pointing to Asterisk
        $uac_req(hdrs) = "Contact: " + $var(asterisk_contact) + "\r\n";
        $uac_req(hdrs) = $uac_req(hdrs) + "Expires: " + $(hdr(Expires)) + "\r\n";
        
        xlog("L_INFO", "Sending REGISTER to Genesys for DN $var(dn) with Contact: $var(asterisk_contact)\n");
        uac_req_send();
    }
    
    if (status =~ "^[12][0-9][0-9]" && $pr =~ "ws") {
        xlog("L_INFO", "WebSocket REGISTER to Asterisk successful\n");
    }
}

onreply_route[DISPATCH_REPLY] {
    xlog("L_INFO", "Reply: $rs $rr (method: $rm)\n");
    
    # NAT management for WebSocket
    if (isbflagset(8) && status =~ "^[12][0-9][0-9]") {
        if ($pr =~ "ws") {
            xlog("L_INFO", "WebSocket reply handled\n");
        }
    }
}

onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "Managing reply: $rs $rr\n");
    
    if (status =~ "^(18[0-9]|200)$" && has_body("application/sdp")) {
        if (!rtpengine_answer("replace-origin replace-session-connection ICE=force DTLS=passive RTP/SAVPF")) {
            xlog("L_ERR", "RTPengine answer failed\n");
        }
    }

    if (status =~ "^[12][0-9][0-9]") {
        if (isbflagset(8) && $pr =~ "ws") {
            xlog("L_INFO", "WebSocket reply - contact alias managed\n");
        }
    }
}

####### Failure Route ########

failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    xlog("L_INFO", "Transaction failed: $rs $rr\n");
}

failure_route[DISPATCH_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }

    xlog("L_WARN", "Dispatch failed: $rs $rr - trying next Asterisk\n");

    # Try next Asterisk instance
    if (ds_next_dst()) {
        xlog("L_INFO", "Trying next destination: $du\n");
        t_on_failure("DISPATCH_FAILURE");
        route(RELAY);
        exit;
    }

    xlog("L_ERR", "All Asterisk backends failed\n");
}

####### Event Routes ########

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection closed from $si:$sp\n");
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp != 8080 && $Rp != 5060) {
        xlog("L_WARN", "HTTP request to wrong port $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    xlog("L_INFO", "HTTP Request: $rm $hu from $si:$sp\n");

    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
        # WebSocket handshake
        if (ws_handle_handshake()) {
            xlog("L_INFO", "WebSocket handshake successful\n");
            exit;
        } else {
            xlog("L_ERR", "WebSocket handshake failed\n");
            xhttp_reply("400", "Bad Request", "", "");
            exit;
        }
    }

    xhttp_reply("200", "OK", "text/html", "<html><body><h1>Kamailio WebRTC Proxy</h1><p>WebSocket endpoint: ws://192.168.210.54:8080/ws (internal) or wss://192.168.210.54:8443/ws (via Nginx proxy)</p></body></html>");
}


