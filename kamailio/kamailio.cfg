#!KAMAILIO

####### Global Parameters #########

# Debug level
debug=2
log_stderror=no
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# Number of child processes
children=8

# Disable TCP (enable if needed)
disable_tcp=no

# Enable WebSocket
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=ws:0.0.0.0:8080
listen=wss:0.0.0.0:4443

# TLS Configuration
enable_tls=yes
tls_port_no=5061

####### Custom Parameters #########

# WebRTC and SIP parameters
#!define ASTERISK_IP "127.0.0.1"
#!define ASTERISK_PORT "5060"
#!define LISTEN_IP "0.0.0.0"
#!define PUBLIC_IP "YOUR_PUBLIC_IP_HERE"
#!define DOMAIN "your-domain.com"

# MySQL connection
#!define DBURL "mysql://kamailio:kamailiopass@mysql/kamailio"

####### Modules Section #########

# Load path
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

# Core modules
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

# Database modules
loadmodule "db_mysql.so"
loadmodule "sqlops.so"

# Authentication modules
loadmodule "auth.so"
loadmodule "auth_db.so"

# NAT traversal modules
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

# WebSocket support
loadmodule "websocket.so"
loadmodule "xhttp.so"

# TLS support
loadmodule "tls.so"

# Presence (optional)
loadmodule "presence.so"
loadmodule "presence_xml.so"

# Additional
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "dialog.so"
loadmodule "dispatcher.so"

####### Module Parameters #########

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
modparam("jsonrpcs", "transport", 7)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)

# ----- usrloc params -----
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 1)

# ----- auth_db params -----
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 1)

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)

# ----- htable params -----
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- dialog params -----
modparam("dialog", "dlg_flag", 4)
modparam("dialog", "default_timeout", 21600)
modparam("dialog", "db_mode", 2)
modparam("dialog", "db_url", DBURL)

# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")

####### Routing Logic #########

request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
        dlg_manage();
    }

    # Handle registrations
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    if ($rU == $null) {
        sl_send_reply("484", "Address Incomplete");
        exit;
    }

    # Route to Asterisk
    route(TOASTERISK);
}

# Routing to Asterisk
route[TOASTERISK] {
    xlog("L_INFO", "Routing to Asterisk: $ru\n");
    
    # Apply RTP proxy for WebRTC
    if (nat_uac_test("8")) {
        route(NATMANAGE);
    }
    
    # Set destination to Asterisk
    $du = "sip:" + ASTERISK_IP + ":" + ASTERISK_PORT;
    
    route(RELAY);
}

# Request initial checks
route[REQINIT] {
    # Flood detection
    if (!pike_check_req()) {
        xlog("L_ALERT", "ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
    
    if ($sht(ipban=>$si) != $null) {
        xlog("L_ALERT", "ALERT: Request from banned IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }

    # Max forwards check
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # OPTIONS processing
    if (is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }

    # Sanity check
    if (!sanity_check("17895", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
    return;
}

# RTP proxy control and NAT traversal
route[NATMANAGE] {
    if (is_request()) {
        if (has_totag()) {
            if (check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    
    if (!(isflagset(5) || isbflagset(6))) {
        return;
    }

    if (is_request()) {
        if (!has_totag()) {
            if (t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    
    if (is_reply()) {
        if (isbflagset(6)) {
            if (is_first_hop()) {
                set_contact_alias();
            }
        }
    }

    # RTP Engine for WebRTC
    if (is_method("INVITE|UPDATE")) {
        if (sdp_content()) {
            if ($pr == "ws" || $pr == "wss") {
                xlog("L_INFO", "WebRTC call, engaging RTPEngine\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/SAVPF RTP/AVP");
            } else if ($proto == "udp" || $proto == "tcp") {
                xlog("L_INFO", "SIP call, engaging RTPEngine\n");
                rtpengine_manage("replace-origin replace-session-connection ICE=remove RTP/AVP");
            }
        }
    }
    
    if (is_method("ACK") && has_body("application/sdp")) {
        rtpengine_manage();
    }
    
    if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    return;
}

# Caller NAT detection
route[NATMANAGE_REPLY] {
    if (is_request()) {
        return;
    }
    
    if (!(isflagset(5) || isbflagset(6))) {
        return;
    }

    if (is_reply() && isbflagset(6)) {
        set_contact_alias();
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1);
            setflag(3);
        } else if (is_method("INVITE")) {
            record_route();
        }
        
        if (is_method("ACK")) {
            route(NATMANAGE);
        }
        
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }
    
    sl_send_reply("404", "Not here");
    exit;
}

# URI update for dialog requests
route[DLGURI] {
    if (!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# User registration
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;
    
    if (isflagset(5)) {
        setbflag(6);
    }
    
    # Forward to Asterisk for authentication and registration
    $du = "sip:" + ASTERISK_IP + ":" + ASTERISK_PORT;
    route(RELAY);
}

# Relay messages
route[RELAY] {
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if (isflagset(5) || isbflagset(6)) {
            route(NATMANAGE);
        }
    }
    
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("incoming reply\n");
    if (status =~ "(183)|(2[0-9][0-9])") {
        route(NATMANAGE_REPLY);
    }
}

# Manage failure routing
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }
}

# WebSocket handling
event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();
    
    if ($Rp != 8080 && $Rp != 4443) {
        xlog("L_WARN", "HTTP request received on $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    xlog("L_DBG", "HTTP Request Received\n");

    if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm =~ "GET") {
        xlog("L_DBG", "WebSocket request from $si:$sp\n");
        
        if (ws_handle_handshake()) {
            exit;
        }
    }
    
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}




