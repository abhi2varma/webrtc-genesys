#!KAMAILIO
#
# Kamailio SIP Proxy - WebRTC Gateway POC Configuration
# Purpose: SIP load balancer and registrar for Asterisk cluster
# POC: Single Asterisk instance (192.168.210.54)
#

####### Global Parameters #########

# Debug level (2=NOTICE, 3=INFO, 4=DEBUG)
debug=2
log_stderror=yes
log_facility=LOG_LOCAL0

# Log to file
log_prefix="{$mt $hdr(CSeq) $ci} "
log_name="kamailio"

fork=yes
children=4

# Listen on all interfaces
listen=udp:192.168.210.54:5060
# listen=tcp:192.168.210.54:5060  # Uncomment if TCP needed

# Server header
server_signature=no
user_agent_header="User-Agent: Kamailio SIP Proxy"

####### Modules Section ########

# Load modules
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "dispatcher.so"

# NAT traversal (not needed - Asterisk handles WebRTC NAT)
# loadmodule "nathelper.so"
# loadmodule "rtpengine.so"

####### Module Parameters ########

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- dispatcher params -----
modparam("dispatcher", "list_file", "/etc/kamailio/dispatcher.list")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_interval", 10)
modparam("dispatcher", "ds_ping_from", "sip:kamailio@192.168.210.54")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_probing_threshold", 3)

# ----- nathelper params ----- (disabled - not needed for POC)
# modparam("nathelper", "natping_interval", 30)
# modparam("nathelper", "ping_nated_only", 1)
# modparam("nathelper", "sipping_bflag", 7)
# modparam("nathelper", "sipping_from", "sip:pinger@192.168.210.54")

####### Routing Logic ########

# Main SIP request routing logic
request_route {
    # Per SIP request initial checks
    route(REQINIT);

    # NAT detection (disabled - Asterisk handles it)
    # route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Check for unsupported methods
    if (is_method("PUBLISH|SUBSCRIBE")) {
        sl_send_reply("503", "Service Unavailable");
        exit;
    }

    # REGISTER requests
    if (is_method("REGISTER")) {
        # Forward to Asterisk for registration
        route(DISPATCH);
        exit;
    }

    # Check destination
    if ($rU==$null) {
        # Request with no username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # Dispatch to Asterisk
    route(DISPATCH);
}

# Wrapper for relaying requests
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    # Flood detection
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (src_ip!="192.168.210.54" && src_ip!="192.168.210.81") {
        # Block traffic not from our network (basic security)
        xlog("L_WARN", "Request from untrusted source: $si\n");
        # Allow for POC, but log it
        # exit;
    }

    # Sanity checks
    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # Sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(DLGURI);
        if (is_method("BYE")) {
            setflag(1); # do accounting
            setflag(3); # CDR flag
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(NATMANAGE);
        } else if ( is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if ( t_check_trans() ) {
            # No loose-route, but stateful ACK
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Caller NAT detection (disabled - not needed)
route[NATDETECT] {
    return;
}

# RTPEngine control and NAT management (disabled - not needed)
route[NATMANAGE] {
    return;
}

# URI update for dialog requests
route[DLGURI] {
    if(!isdsturiset()) {
        handle_ruri_alias();
    }
    return;
}

# Dispatch to Asterisk instances
route[DISPATCH] {
    # Select destination from dispatcher
    if(!ds_select_dst("1", "4")) {
        send_reply("503", "Service Unavailable");
        exit;
    }

    xlog("L_INFO", "Dispatching $rm from $fu to $du\n");

    # Forward to selected Asterisk
    route(RELAY);
    exit;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) {
        exit;
    }

    # Handle failover to next Asterisk (for multi-instance)
    if (t_check_status("(408)|([56][0-9][0-9])")) {
        xlog("L_INFO", "Failed destination $du - trying next\n");
        if(ds_next_dst()) {
            route(RELAY);
            exit;
        }
    }
}

